defmodule GitTest do
  use ExUnit.Case
  doctest Expublish

  import ExUnit.CaptureLog
  alias Expublish.Git
  alias Expublish.Options

  @version Version.parse!("1.0.1")

  setup do
    [options: Options.parse(["--dry-run", "--disable-push"]), version: @version]
  end

  test "validate/0 runs without errors" do
    assert :ok == Git.validate()
  end

  test "validate/1 runs without errors", %{options: options} do
    assert :ok == Git.validate(options)
  end

  test "validate/1 returns error message if working directory is not clean", %{options: options} do
    File.write!("expublish_git_validate_test", "generated by expublish test")

    assert Git.validate(options) =~ "Git working directory not clean"

    File.rm!("expublish_git_validate_test")
  end

  test "validate/1 may allow untracked files", %{options: options} do
    File.write!("expublish_git_validate_test", "generated by expublish test")

    assert :ok == Git.validate(%{options | allow_untracked: true})

    File.rm!("expublish_git_validate_test")
  end

  test "commit_and_tag/3 does expected system calls", %{version: version} do
    options = %Options{}

    fun = fn ->
      Git.commit_and_tag(version, options)
    end

    git_tag = "#{options.tag_prefix}#{version}"
    commit_message = "#{options.commit_prefix} #{version}"

    assert capture_log(fun) =~ "Creating new version commit"
    assert capture_log(fun) =~ "Creating new version tag"
    assert capture_log(fun) =~ "#{version}"

    assert capture_log(fun) =~ "git add ."
    assert capture_log(fun) =~ "git commit -qm #{commit_message}"
    assert capture_log(fun) =~ "git tag -a #{git_tag} -m #{commit_message}"
  end

  test "commit_and_tag/1 logs an info message", %{options: options, version: version} do
    fun = fn ->
      Git.commit_and_tag(version, options)
    end

    assert capture_log(fun) =~ "Skipping new version commit"
    assert capture_log(fun) =~ "Skipping new version tag"
    assert capture_log(fun) =~ "#{version}"
  end

  test "commit_and_tag/1 respects tag- and commit-prefix options", %{version: version} do
    options =
      Options.parse(["--dry-run", "--tag-prefix=rc", "--commit-prefix='Custom release commit'"])

    fun = fn ->
      Git.commit_and_tag(version, options)
    end

    assert capture_log(fun) =~ "Custom release commit #{version}"
    assert capture_log(fun) =~ "rc#{version}"
  end

  test "push/1 does expected system call", %{version: version} do
    fun = fn ->
      Git.push(version)
    end

    assert capture_log(fun) =~ "Pushing new package version"
    assert capture_log(fun) =~ "git push origin master --tags"
  end

  test "push/2 does expected system call", %{version: version} do
    options = %Options{}

    fun = fn ->
      Git.push(version, options)
    end

    assert capture_log(fun) =~ "Pushing new package version"
    assert capture_log(fun) =~ "git push #{options.remote} #{options.branch} --tags"
  end
end
