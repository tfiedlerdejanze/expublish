defmodule ExpublishTest do
  use ExUnit.Case
  doctest Expublish

  import ExUnit.CaptureLog
  alias Expublish.Options

  setup do
    [options: Options.parse(["--dry-run"])]
  end

  test "major/1 exits on unclean working directory", %{options: options} do
    File.write!("expublish_major_test", "generated by expublish test")

    assert catch_exit(Expublish.major(options)) == :shutdown

    File.rm!("expublish_major_test")
  end

  test "major/1 logs on unclean working directory", %{options: options} do
    File.write!("expublish_major_test", "generated by expublish test")

    fun = fn -> catch_exit(Expublish.major(options)) end

    assert capture_log(fun) =~ "working directory not clean"

    File.rm!("expublish_major_test")
  end

  test "major/1 runs without errors", %{options: options} do
    fun = fn ->
      test_publish(fn ->
        Expublish.major(options)
      end)
    end

    assert capture_log(fun) =~ "new package version"
  end

  test "minor/1 runs without errors", %{options: options} do
    fun = fn ->
      test_publish(fn ->
        Expublish.minor(options)
      end)
    end

    assert capture_log(fun) =~ "Skipping new entry in CHANGELOG.md"
    assert capture_log(fun) =~ "Skipping version commit"
    assert capture_log(fun) =~ "Skipping version tag"
    assert capture_log(fun) =~ "Skipping \"git push origin master --tags\""
    assert capture_log(fun) =~ "Skipping mix hex.publish"
    assert capture_log(fun) =~ "Finished dry run for new package version"
  end

  test "patch/1 runs without errors", %{options: options} do
    fun = fn ->
      test_publish(fn ->
        Expublish.patch(options)
      end)
    end

    assert capture_log(fun) =~ "new package version"
  end

  def test_publish(fun) do
    if File.exists?("RELEASE.md") do
      fun.()
    else
      File.write!("RELEASE.md", "generated by expublish test")
      fun.()
      File.rm!("RELEASE.md")
    end
  end
end
